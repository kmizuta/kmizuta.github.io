<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_35) on Sat Mar 14 08:39:38 PDT 2015 -->
<TITLE>
ADFPreferences (Oracle Fusion Middleware Java API Reference for Oracle ADF Share)
</TITLE>

<META NAME="date" CONTENT="2015-03-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ADFPreferences (Oracle Fusion Middleware Java API Reference for Oracle ADF Share)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Oracle Fusion Middleware Java API Reference for Oracle ADF Share<br>11g Release 1 (11.1.1.9.0)</b><br>E52934-01</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../oracle/adf/share/prefs/ADFPreferencesFactory.html" title="class in oracle.adf.share.prefs"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?oracle/adf/share/prefs/ADFPreferences.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ADFPreferences.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
oracle.adf.share.prefs</FONT>
<BR>
Class ADFPreferences</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by ">java.util.prefs.Preferences
      <IMG SRC="../../../../resources/inherit.gif" ALT="extended by ">java.util.prefs.AbstractPreferences
          <IMG SRC="../../../../resources/inherit.gif" ALT="extended by "><B>oracle.adf.share.prefs.ADFPreferences</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>ADFPreferences</B><DT>extends java.util.prefs.AbstractPreferences</DL>
</PRE>

<P>
An implementation of <CODE>Preferences</CODE> class providing
 a MDS repository based persistence mechanism. This class also provides a
 richer user level preferences, using the J2EE authenticated user. It also
 enables access to preference objects, which return preferences based on a
 user over system ordering.<br>
 It should be noted that accessing Preference objects directly though the
 statics in this class assumes that the Preference Utility is being used
 within the context of an ADF Web Application. As such the details required
 to connect to the MDS Repository are obtained by the utility from the
 ADF Context. <br>
 Consumers wanting to use the ADFPreferences Utility outside of the scope of
 an ADF Web Application should only access ADFPreferences objects through the
 ADFPreferencesFactory class which has been constructed passing into it the
 ADFPreferencesSimpleConfig object, that has inturn been constructed by
 passing in a MDSInstance object.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#FILENAME">FILENAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The filename used for the MDS preference documents</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../oracle/adf/share/prefs/ADFPreferencesManager.html" title="class in oracle.adf.share.prefs">ADFPreferencesManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#mManager">mManager</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The ADFPreferencesManager object that helps manages the preferences</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.util.prefs.AbstractPreferences"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class java.util.prefs.AbstractPreferences</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>lock, newNode</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.util.prefs.Preferences"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class java.util.prefs.Preferences</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>MAX_KEY_LENGTH, MAX_NAME_LENGTH, MAX_VALUE_LENGTH</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#ADFPreferences(java.util.prefs.AbstractPreferences, java.lang.String)">ADFPreferences</A></B>(java.util.prefs.AbstractPreferences&nbsp;parent,
               java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a preference node with the specified parent and the specified
 name relative to its parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#ADFPreferences(oracle.adf.share.prefs.ADFPreferencesManager, java.lang.String)">ADFPreferences</A></B>(<A HREF="../../../../oracle/adf/share/prefs/ADFPreferencesManager.html" title="class in oracle.adf.share.prefs">ADFPreferencesManager</A>&nbsp;manager,
               java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor used to create a Preference object and set against it the
 specified MDSHelper object, which will have been created with the path
 and customization context required for this Preference object.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#bulkGet()">bulkGet</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method enables a bulk get of all preference items that are accessible
 on this particular preference node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#bulkGet(java.util.Set)">bulkGet</A></B>(java.util.Set&lt;java.lang.String&gt;&nbsp;prefSet)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method enables a bulk get of a specified set of preference items that
 are accessible on this particular preference node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#bulkPut(java.util.Map)">bulkPut</A></B>(java.util.Map&lt;java.lang.String,java.lang.String&gt;&nbsp;putMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method enables bulk putting of a set of Preference items (String key,
 String value map elements).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#childrenNamesSpi()">childrenNamesSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the names of the children of this preference node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.prefs.AbstractPreferences</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#childSpi(java.lang.String)">childSpi</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the named child of this preference node, creating it if it does
 not already exist.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#flushSpi()">flushSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is invoked with this node locked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#get(java.lang.String, java.lang.String)">get</A></B>(java.lang.String&nbsp;key,
    java.lang.String&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;oracle.adf.share.prefs.MDSHelper</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#getMDSHelper()">getMDSHelper</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the MDSHelper object associated with this Preference node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#getMDSPathForExport(java.util.prefs.Preferences)">getMDSPathForExport</A></B>(java.util.prefs.Preferences&nbsp;prefs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the full MDS path associated with the Preferences object
 passed into the method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#getMDSPathForExport(java.lang.String)">getMDSPathForExport</A></B>(java.lang.String&nbsp;preferencePath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the full MDS path associated with the Preferences path
 passed into the method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#getSpi(java.lang.String)">getSpi</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the value associated with the specified key at this preference
 node, or <tt>null</tt> if there is no association for this key, or the
 association cannot be determined at this time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;oracle.mds.cust.CustomizationClass</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#getSystemCustomizationClass()">getSystemCustomizationClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the CustomizationClass associated with the System
 Customizations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;oracle.mds.cust.CustomizationClass</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#getUserCustomizationClass()">getUserCustomizationClass</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the CustomizationClass associated with the User
 Customizations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#keysSpi()">keysSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all of the keys that have an associated value in this
 preference node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#put(java.lang.String, java.lang.String)">put</A></B>(java.lang.String&nbsp;key,
    java.lang.String&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#putSpi(java.lang.String, java.lang.String)">putSpi</A></B>(java.lang.String&nbsp;key,
       java.lang.String&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put the given key-value association into this preference node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#remove(java.lang.String)">remove</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#removeNodeSpi()">removeNodeSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes this preference node, invalidating it and any preferences that
 it contains.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#removeSpi(java.lang.String)">removeSpi</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the association (if any) for the specified key at this
 preference node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#setUsernameOverride(java.lang.String)">setUsernameOverride</A></B>(java.lang.String&nbsp;username)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables overriding the ADFContext based username derivation in 
 Preferences access.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#syncSpi()">syncSpi</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is invoked with this node locked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.prefs.Preferences</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#systemNodeForPackage(java.lang.Class)">systemNodeForPackage</A></B>(java.lang.Class&lt;?&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the preference node from the system preference tree that is
 associated (by convention) with the specified class's package.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.prefs.Preferences</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#systemRoot()">systemRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the root preference node for the system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.prefs.Preferences</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#userNodeForPackage(java.lang.Class)">userNodeForPackage</A></B>(java.lang.Class&lt;?&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the preference node from the calling user's preference tree
 that is associated (by convention) with the specified class's package.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html" title="class in oracle.adf.share.prefs">ADFPreferences</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#userOverSystemNodeForPackage(java.lang.Class)">userOverSystemNodeForPackage</A></B>(java.lang.Class&lt;?&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the preference node associated with the MDS
 customization array's preference tree that is associated
 (by convention) with the specified class's package.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.prefs.Preferences</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#userOverSystemRoot()">userOverSystemRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the root preference node for MDS sessions customization
 configuration specified in adf-config.xml</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.prefs.Preferences</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html#userRoot()">userRoot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the root preference node for the calling user.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.prefs.AbstractPreferences"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.util.prefs.AbstractPreferences</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>absolutePath, addNodeChangeListener, addPreferenceChangeListener, cachedChildren, childrenNames, clear, exportNode, exportSubtree, flush, getBoolean, getByteArray, getChild, getDouble, getFloat, getInt, getLong, isRemoved, isUserNode, keys, name, node, nodeExists, parent, putBoolean, putByteArray, putDouble, putFloat, putInt, putLong, removeNode, removeNodeChangeListener, removePreferenceChangeListener, sync, toString</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.prefs.Preferences"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.util.prefs.Preferences</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>importPreferences</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="mManager"><!-- --></A><H3>
mManager</H3>
<PRE>
protected final <A HREF="../../../../oracle/adf/share/prefs/ADFPreferencesManager.html" title="class in oracle.adf.share.prefs">ADFPreferencesManager</A> <B>mManager</B></PRE>
<DL>
<DD>The ADFPreferencesManager object that helps manages the preferences
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="FILENAME"><!-- --></A><H3>
FILENAME</H3>
<PRE>
protected static final java.lang.String <B>FILENAME</B></PRE>
<DL>
<DD>The filename used for the MDS preference documents
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#oracle.adf.share.prefs.ADFPreferences.FILENAME">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ADFPreferences(oracle.adf.share.prefs.ADFPreferencesManager, java.lang.String)"><!-- --></A><H3>
ADFPreferences</H3>
<PRE>
protected <B>ADFPreferences</B>(<A HREF="../../../../oracle/adf/share/prefs/ADFPreferencesManager.html" title="class in oracle.adf.share.prefs">ADFPreferencesManager</A>&nbsp;manager,
                         java.lang.String&nbsp;path)
                  throws oracle.mds.config.MDSConfigurationException,
                         oracle.mds.core.MetadataExistsException,
                         oracle.mds.exception.UnsupportedUpdateException,
                         oracle.mds.persistence.MDSIOException,
                         oracle.mds.core.ConcurrentMOChangeException,
                         oracle.mds.core.ValidationException,
                         java.lang.ClassNotFoundException,
                         oracle.mds.exception.MDSException</PRE>
<DL>
<DD>Constructor used to create a Preference object and set against it the
 specified MDSHelper object, which will have been created with the path
 and customization context required for this Preference object. This
 method is for internal use only and not to be publically accessible.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>manager</CODE> - The manager associated with this Preference object.
<DT><B>Throws:</B>
<DD><CODE>oracle.mds.config.MDSConfigurationException</CODE>
<DD><CODE>oracle.mds.core.MetadataExistsException</CODE>
<DD><CODE>oracle.mds.exception.UnsupportedUpdateException</CODE>
<DD><CODE>oracle.mds.persistence.MDSIOException</CODE>
<DD><CODE>oracle.mds.core.ConcurrentMOChangeException</CODE>
<DD><CODE>oracle.mds.core.ValidationException</CODE>
<DD><CODE>java.lang.ClassNotFoundException</CODE>
<DD><CODE>oracle.mds.exception.MDSException</CODE></DL>
</DL>
<HR>

<A NAME="ADFPreferences(java.util.prefs.AbstractPreferences, java.lang.String)"><!-- --></A><H3>
ADFPreferences</H3>
<PRE>
public <B>ADFPreferences</B>(java.util.prefs.AbstractPreferences&nbsp;parent,
                      java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Creates a preference node with the specified parent and the specified
 name relative to its parent.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>parent</CODE> - the parent of this preference node, or null if this
               is the root.<DD><CODE>name</CODE> - the name of this preference node, relative to its parent,
             or <tt>""</tt> if this is the root.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <tt>name</tt> contains a slash
          (<tt>'/'</tt>),  or <tt>parent</tt> is <tt>null</tt> and
          name isn't <tt>""</tt>.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getSpi(java.lang.String)"><!-- --></A><H3>
getSpi</H3>
<PRE>
public java.lang.String <B>getSpi</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Return the value associated with the specified key at this preference
 node, or <tt>null</tt> if there is no association for this key, or the
 association cannot be determined at this time.  It is guaranteed that
 <tt>key</tt> is non-null.  Also, it is guaranteed that this node has
 not been removed.  (The implementor needn't check for either of these
 things.)

 <p> Generally speaking, this method should not throw an exception
 under any circumstances.  If, however, if it does throw an exception,
 the exception will be intercepted and treated as a <tt>null</tt>
 return value.

 <p>This method is invoked with the lock on this node held.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>getSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the value associated with the specified key at this preference
          node, or <tt>null</tt> if there is no association for this
          key, or the association cannot be determined at this time.</DL>
</DD>
</DL>
<HR>

<A NAME="putSpi(java.lang.String, java.lang.String)"><!-- --></A><H3>
putSpi</H3>
<PRE>
public void <B>putSpi</B>(java.lang.String&nbsp;key,
                   java.lang.String&nbsp;value)</PRE>
<DL>
<DD>Put the given key-value association into this preference node.  It is
 guaranteed that <tt>key</tt> and <tt>value</tt> are non-null and of
 legal length.  Also, it is guaranteed that this node has not been
 removed.  (The implementor needn't check for any of these things.)

 <p>This method is invoked with the lock on this node held.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>putSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeSpi(java.lang.String)"><!-- --></A><H3>
removeSpi</H3>
<PRE>
public void <B>removeSpi</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>Remove the association (if any) for the specified key at this
 preference node.  It is guaranteed that <tt>key</tt> is non-null.
 Also, it is guaranteed that this node has not been removed.
 (The implementor needn't check for either of these things.)

 <p>This method is invoked with the lock on this node held.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>removeSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="childSpi(java.lang.String)"><!-- --></A><H3>
childSpi</H3>
<PRE>
public java.util.prefs.AbstractPreferences <B>childSpi</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns the named child of this preference node, creating it if it does
 not already exist.  It is guaranteed that <tt>name</tt> is non-null,
 non-empty, does not contain the slash character ('/'), and is no longer
 than <CODE>Preferences.MAX_NAME_LENGTH</CODE> characters.  Also, it is guaranteed that
 this node has not been removed.  (The implementor needn't check for any
 of these things.)

 <p>Finally, it is guaranteed that the named node has not been returned
 by a previous invocation of this method or <CODE>AbstractPreferences.getChild(String)</CODE>
 after the last time that it was removed.  In other words, a cached
 value will always be used in preference to invoking this method.
 Subclasses need not maintain their own cache of previously returned
 children.

 <p>The implementer must ensure that the returned node has not been
 removed.  If a like-named child of this node was previously removed, the
 implementer must return a newly constructed <tt>AbstractPreferences</tt>
 node; once removed, an <tt>AbstractPreferences</tt> node
 cannot be "resuscitated."

 <p>If this method causes a node to be created, this node is not
 guaranteed to be persistent until the <tt>flush</tt> method is
 invoked on this node or one of its ancestors (or descendants).

 <p>This method is invoked with the lock on this node held.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>childSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - The name of the child node to return, relative to
        this preference node.
<DT><B>Returns:</B><DD>The named child node.</DL>
</DD>
</DL>
<HR>

<A NAME="removeNodeSpi()"><!-- --></A><H3>
removeNodeSpi</H3>
<PRE>
public void <B>removeNodeSpi</B>()
                   throws java.util.prefs.BackingStoreException</PRE>
<DL>
<DD>Removes this preference node, invalidating it and any preferences that
 it contains.  The named child will have no descendants at the time this
 invocation is made (i.e., the <CODE>Preferences.removeNode()</CODE> method
 invokes this method repeatedly in a bottom-up fashion, removing each of
 a node's descendants before removing the node itself).

 <p>This method is invoked with the lock held on this node and its
 parent (and all ancestors that are being removed as a
 result of a single invocation to <CODE>Preferences.removeNode()</CODE>).

 <p>The removal of a node needn't become persistent until the
 <tt>flush</tt> method is invoked on this node (or an ancestor).

 <p>If this node throws a <tt>BackingStoreException</tt>, the exception
 will propagate out beyond the enclosing <CODE>AbstractPreferences.removeNode()</CODE>
 invocation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>removeNodeSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.util.prefs.BackingStoreException</CODE> - if this operation cannot be completed
         due to a failure in the backing store, or inability to
         communicate with it.</DL>
</DD>
</DL>
<HR>

<A NAME="keysSpi()"><!-- --></A><H3>
keysSpi</H3>
<PRE>
public java.lang.String[] <B>keysSpi</B>()
                           throws java.util.prefs.BackingStoreException</PRE>
<DL>
<DD>Returns all of the keys that have an associated value in this
 preference node.  (The returned array will be of size zero if
 this node has no preferences.)  It is guaranteed that this node has not
 been removed.

 <p>This method is invoked with the lock on this node held.

 <p>If this node throws a <tt>BackingStoreException</tt>, the exception
 will propagate out beyond the enclosing <CODE>AbstractPreferences.keys()</CODE> invocation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>keysSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an array of the keys that have an associated value in this
         preference node.
<DT><B>Throws:</B>
<DD><CODE>java.util.prefs.BackingStoreException</CODE> - if this operation cannot be completed
         due to a failure in the backing store, or inability to
         communicate with it.</DL>
</DD>
</DL>
<HR>

<A NAME="childrenNamesSpi()"><!-- --></A><H3>
childrenNamesSpi</H3>
<PRE>
public java.lang.String[] <B>childrenNamesSpi</B>()
                                    throws java.util.prefs.BackingStoreException</PRE>
<DL>
<DD>Returns the names of the children of this preference node.  (The
 returned array will be of size zero if this node has no children.)
 This method need not return the names of any nodes already cached,
 but may do so without harm.

 <p>This method is invoked with the lock on this node held.

 <p>If this node throws a <tt>BackingStoreException</tt>, the exception
 will propagate out beyond the enclosing <CODE>AbstractPreferences.childrenNames()</CODE>
 invocation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>childrenNamesSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an array containing the names of the children of this
         preference node.
<DT><B>Throws:</B>
<DD><CODE>java.util.prefs.BackingStoreException</CODE> - if this operation cannot be completed
         due to a failure in the backing store, or inability to
         communicate with it.</DL>
</DD>
</DL>
<HR>

<A NAME="flushSpi()"><!-- --></A><H3>
flushSpi</H3>
<PRE>
public void <B>flushSpi</B>()
              throws java.util.prefs.BackingStoreException</PRE>
<DL>
<DD>This method is invoked with this node locked.  The contract of this
 method is to force any cached changes in the contents of this
 preference node to the backing store, guaranteeing their persistence.
 (It is perfectly possible that this node does not exist on the backing
 store, either because it has been deleted by another VM, or because it
 has not yet been created.)  Note that this method should <i>not</i>
 flush the preferences in any subnodes of this node.  If the backing
 store naturally flushes an entire subtree at once, the implementer is
 encouraged to override flush(), rather than merely overriding this
 method.

 <p>If this node throws a <tt>BackingStoreException</tt>, the exception
 will propagate out beyond the enclosing <CODE>AbstractPreferences.flush()</CODE> invocation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>flushSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.util.prefs.BackingStoreException</CODE> - if this operation cannot be completed
         due to a failure in the backing store, or inability to
         communicate with it.</DL>
</DD>
</DL>
<HR>

<A NAME="syncSpi()"><!-- --></A><H3>
syncSpi</H3>
<PRE>
public void <B>syncSpi</B>()
             throws java.util.prefs.BackingStoreException</PRE>
<DL>
<DD>This method is invoked with this node locked.  The contract of this
 method is to synchronize any cached preferences stored at this node
 with any stored in the backing store.  (It is perfectly possible that
 this node does not exist on the backing store, either because it has
 been deleted by another VM, or because it has not yet been created.)
 Note that this method should <i>not</i> synchronize the preferences in
 any subnodes of this node.  If the backing store naturally syncs an
 entire subtree at once, the implementer is encouraged to override
 sync(), rather than merely overriding this method.

 <p>If this node throws a <tt>BackingStoreException</tt>, the exception
 will propagate out beyond the enclosing <CODE>AbstractPreferences.sync()</CODE> invocation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>syncSpi</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.util.prefs.BackingStoreException</CODE> - if this operation cannot be completed
         due to a failure in the backing store, or inability to
         communicate with it.</DL>
</DD>
</DL>
<HR>

<A NAME="userOverSystemRoot()"><!-- --></A><H3>
userOverSystemRoot</H3>
<PRE>
public static java.util.prefs.Preferences <B>userOverSystemRoot</B>()</PRE>
<DL>
<DD>Returns the root preference node for MDS sessions customization
 configuration specified in adf-config.xml
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the root preference node for the MDS sessions customization
 configuration specified in adf-config.xml
<DT><B>Throws:</B>
<DD><CODE>java.lang.SecurityException</CODE> - If a security manager is present and
         it denies <tt>RuntimePermission("preferences")</tt>.<DT><B>See Also:</B><DD><CODE>RuntimePermission</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="userOverSystemNodeForPackage(java.lang.Class)"><!-- --></A><H3>
userOverSystemNodeForPackage</H3>
<PRE>
public static <A HREF="../../../../oracle/adf/share/prefs/ADFPreferences.html" title="class in oracle.adf.share.prefs">ADFPreferences</A> <B>userOverSystemNodeForPackage</B>(java.lang.Class&lt;?&gt;&nbsp;c)</PRE>
<DL>
<DD>Returns the preference node associated with the MDS
 customization array's preference tree that is associated
 (by convention) with the specified class's package. The MDS customization
 level is obtained from the adf-config.xml configuiration associated
 with the MDS Session. The convention is as follows: the absolute
 path name of the node is the fully qualified package name,
 preceded by a slash (<tt>'/'</tt>), and with each period
 (<tt>'.'</tt>) replaced by a slash.  For example the
 absolute path name of the node associated with the class
 <tt>com.acme.widget</tt> is <tt>/com/acme/widget</tt>.

 <p>This convention does not apply to the unnamed package, whose
 associated preference node is <tt>&lt;unnamed&gt;</tt>.  This node
 is not intended for long term use, but for convenience in the early
 development of programs that do not yet belong to a package, and
 for "throwaway" programs.  <i>Valuable data should not be stored
 at this node as it is shared by all programs that use it.</i>

 <p>A class <tt>Foo</tt> wishing to access preferences pertaining to its
 package can obtain a preference node as follows: <pre>
    static Preferences prefs = Preferences.nodeForPackage(Foo.class);
 </pre>
 This idiom obviates the need for using a string to describe the
 preferences node and decreases the likelihood of a run-time failure.
 (If the class name is misspelled, it will typically result in a
 compile-time error.)

 <p>Invoking this method will result in the creation of the returned
 node and its ancestors if they do not already exist.  If the returned
 node did not exist prior to this call, this node and any ancestors that
 were created by this call are not guaranteed to become permanent until
 the <tt>flush</tt> method is called on the returned node (or one of its
 ancestors or descendants).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - the class for whose package a MDS Sesson configuration
 customization level preference node is desired.
<DT><B>Returns:</B><DD>the MDS Sesson configuration preference node associated
         with the package of which <tt>c</tt> is a member.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>c</tt> is <tt>null</tt>.
<DD><CODE>java.lang.SecurityException</CODE> - if a security manager is present and
         it denies <tt>RuntimePermission("preferences")</tt>.<DT><B>See Also:</B><DD><CODE>RuntimePermission</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getMDSHelper()"><!-- --></A><H3>
getMDSHelper</H3>
<PRE>
protected oracle.adf.share.prefs.MDSHelper <B>getMDSHelper</B>()</PRE>
<DL>
<DD>Returns the MDSHelper object associated with this Preference node. The
 helper object is used to interface the preference requirements with the
 MDS backend repository.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The MDSHelper object assoicated with this Preference node.</DL>
</DD>
</DL>
<HR>

<A NAME="get(java.lang.String, java.lang.String)"><!-- --></A><H3>
get</H3>
<PRE>
public java.lang.String <B>get</B>(java.lang.String&nbsp;key,
                            java.lang.String&nbsp;def)</PRE>
<DL>
<DD>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>get</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="put(java.lang.String, java.lang.String)"><!-- --></A><H3>
put</H3>
<PRE>
public void <B>put</B>(java.lang.String&nbsp;key,
                java.lang.String&nbsp;val)</PRE>
<DL>
<DD>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>put</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="bulkPut(java.util.Map)"><!-- --></A><H3>
bulkPut</H3>
<PRE>
public void <B>bulkPut</B>(java.util.Map&lt;java.lang.String,java.lang.String&gt;&nbsp;putMap)</PRE>
<DL>
<DD>This method enables bulk putting of a set of Preference items (String key,
 String value map elements). It is intended to be used as a
 utiltity method for advanced users, as it is not available in the
 java.util.prefs packages.<p>
 Users of this method will have to access the method directly from the
 an ADFPreference object as opposed to a java.util.pref.Preferences class.
 <P>A usage example is given below:<br>
   <blockquote>
   <p> <font face="Courier New, Courier, mono">// Create a bulk set<br>
   Map&lt;String, String&gt; prefsPutMap = new HashMap&lt;String, String&gt;();<br>
   prefsPutMap.put(&quot;pref1&quot;, &quot;value1&quot;);<br>
   prefsPutMap.put(&quot;pref2&quot;, &quot;value2&quot;);<br>
   prefsPutMap.put(&quot;pref3&quot;, &quot;value3&quot;);<br>
   ADFPreferences pref = (ADFPreferences)mPrefFactory.</font>
   <blockquote>  <font face="Courier New, Courier, mono"> userNodeForPackage
   (my.demo.service.PrefAccessor.class);<br></font>
   </blockquote>  <font face="Courier New, Courier, mono">
   pref.bulkPut(prefsPutMap); </font></p>
   </blockquote>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>putMap</CODE> - The Map (String, String) object containing the String key,
 String value map elements to be populated in a bulk manner on the
 preference node associated with this preference object.</DL>
</DD>
</DL>
<HR>

<A NAME="bulkGet()"><!-- --></A><H3>
bulkGet</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.String&gt; <B>bulkGet</B>()</PRE>
<DL>
<DD>This method enables a bulk get of all preference items that are accessible
 on this particular preference node. The preference data is retruned as a
 Map object containing String key, String value items.
 This api is not part of the java.util.pref standard and so is only
 accessible from the ADFPreferences object directly, and not
 java.util.prefs.Preferences
 The example code below assumes the data in the bulkPut exists in the
 preference node. If it doesn't the keys will not exist a null value would
 be returned by the map get(key) call.<br>
 Consumers of this API will need to handle this possibility in their usages
 of the API. <br>
 <blockquote>
 <font face="Courier New, Courier, mono">ADFPreferences prefNode = </font>
  <blockquote> <font face="Courier New, Courier, mono">
  (ADFPreferences)mPrefFactory.userNodeForPackage
  (my.demo.service.PrefAccessor.class);<br></font>
  </blockquote><font face="Courier New, Courier, mono">
  Map&lt;String, String&gt; prefs = pref.bulkGet();<br>
  String pref1Value = prefs.get(&quot;pref1&quot;);<br>
  String pref2Value = prefs.get(&quot;pref2&quot;);<br>
  String pref3Value = prefs.get(&quot;pref3&quot;);</font><br>
 </blockquote>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The map of Sting key, String value items for each preference item
 that has been set against the node associated with this preference object.</DL>
</DD>
</DL>
<HR>

<A NAME="bulkGet(java.util.Set)"><!-- --></A><H3>
bulkGet</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.String&gt; <B>bulkGet</B>(java.util.Set&lt;java.lang.String&gt;&nbsp;prefSet)</PRE>
<DL>
<DD>This method enables a bulk get of a specified set of preference items that
 are accessible on this particular preference node. This utility method is
 expected to be useful to users who know which set of preferences they wish
 to get value for. The Set object passed in to this method has to contain
 a String key element per requested preference. The preference result is a
 Map object containing String key, String value items.
 This api is not part of the java.util.pref standard and so is only
 accessible from the ADFPreferences object directly, and not
 java.util.prefs.Preferences
 The example code below assumes the data in the bulkPut exists in the
 preference node. If it doesn't the keys will not exist a null value would
 be returned by the map get(key) call.<br>
 Consumers of this API will need to handle this possibility in their usages
 of the API.<br>
 <blockquote>
 <font face="Courier New, Courier, mono">ADFPreferences prefNode = </font>
  <blockquote> <font face="Courier New, Courier, mono">
  (ADFPreferences)mPrefFactory.userNodeForPackage
  (my.demo.service.PrefAccessor.class);<br></font>
  </blockquote>
  <font face="Courier New, Courier, mono">
  Set&lt;String&gt; requestedPrefSet= new HashSet&lt;String&gt;(2);   <br>
  s.add("pref1");<br>
  s.add("pref3");<br>
  Map&lt;String, String&gt; prefs = pref.bulkGet(requestedPrefSet);<br>
  String pref1Value = prefs.get(&quot;pref1&quot;);<br>
  String pref3Value = prefs.get(&quot;pref3&quot;);</font><br>
 </blockquote>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The map of Sting key, String value items for each preference item
 that has been set against the node associated with this preference object.</DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.String)"><!-- --></A><H3>
remove</H3>
<PRE>
public void <B>remove</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>remove</CODE> in class <CODE>java.util.prefs.AbstractPreferences</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="systemRoot()"><!-- --></A><H3>
systemRoot</H3>
<PRE>
public static java.util.prefs.Preferences <B>systemRoot</B>()</PRE>
<DL>
<DD>Returns the root preference node for the system.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the root preference node for the system.
<DT><B>Throws:</B>
<DD><CODE>java.lang.SecurityException</CODE> - If a security manager is present and
         it denies <tt>RuntimePermission("preferences")</tt>.<DT><B>See Also:</B><DD><CODE>RuntimePermission</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="userRoot()"><!-- --></A><H3>
userRoot</H3>
<PRE>
public static java.util.prefs.Preferences <B>userRoot</B>()</PRE>
<DL>
<DD>Returns the root preference node for the calling user.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the root preference node for the calling user.
<DT><B>Throws:</B>
<DD><CODE>java.lang.SecurityException</CODE> - If a security manager is present and
         it denies <tt>RuntimePermission("preferences")</tt>.<DT><B>See Also:</B><DD><CODE>RuntimePermission</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="userNodeForPackage(java.lang.Class)"><!-- --></A><H3>
userNodeForPackage</H3>
<PRE>
public static java.util.prefs.Preferences <B>userNodeForPackage</B>(java.lang.Class&lt;?&gt;&nbsp;c)</PRE>
<DL>
<DD>Returns the preference node from the calling user's preference tree
 that is associated (by convention) with the specified class's package.
 The convention is as follows: the absolute path name of the node is the
 fully qualified package name, preceded by a slash (<tt>'/'</tt>), and
 with each period (<tt>'.'</tt>) replaced by a slash.  For example the
 absolute path name of the node associated with the class
 <tt>com.acme.widget</tt> is <tt>/com/acme/widget</tt>.

 <p>This convention does not apply to the unnamed package, whose
 associated preference node is <tt>&lt;unnamed&gt;</tt>.  This node
 is not intended for long term use, but for convenience in the early
 development of programs that do not yet belong to a package, and
 for "throwaway" programs.  <i>Valuable data should not be stored
 at this node as it is shared by all programs that use it.</i>

 <p>A class <tt>Foo</tt> wishing to access preferences pertaining to its
 package can obtain a preference node as follows: <pre>
    static Preferences prefs = Preferences.userNodeForPackage(Foo.class);
 </pre>
 This idiom obviates the need for using a string to describe the
 preferences node and decreases the likelihood of a run-time failure.
 (If the class name is misspelled, it will typically result in a
 compile-time error.)

 <p>Invoking this method will result in the creation of the returned
 node and its ancestors if they do not already exist.  If the returned
 node did not exist prior to this call, this node and any ancestors that
 were created by this call are not guaranteed to become permanent until
 the <tt>flush</tt> method is called on the returned node (or one of its
 ancestors or descendants).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - the class for whose package a user preference node is desired.
<DT><B>Returns:</B><DD>the user preference node associated with the package of which
         <tt>c</tt> is a member.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>c</tt> is <tt>null</tt>.
<DD><CODE>java.lang.SecurityException</CODE> - if a security manager is present and
         it denies <tt>RuntimePermission("preferences")</tt>.<DT><B>See Also:</B><DD><CODE>RuntimePermission</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="systemNodeForPackage(java.lang.Class)"><!-- --></A><H3>
systemNodeForPackage</H3>
<PRE>
public static java.util.prefs.Preferences <B>systemNodeForPackage</B>(java.lang.Class&lt;?&gt;&nbsp;c)</PRE>
<DL>
<DD>Returns the preference node from the system preference tree that is
 associated (by convention) with the specified class's package.  The
 convention is as follows: the absolute path name of the node is the
 fully qualified package name, preceded by a slash (<tt>'/'</tt>), and
 with each period (<tt>'.'</tt>) replaced by a slash.  For example the
 absolute path name of the node associated with the class
 <tt>com.acme.widget</tt> is <tt>/com/acme/widget</tt>.

 <p>This convention does not apply to the unnamed package, whose
 associated preference node is <tt>&lt;unnamed&gt;</tt>.  This node
 is not intended for long term use, but for convenience in the early
 development of programs that do not yet belong to a package, and
 for "throwaway" programs.  <i>Valuable data should not be stored
 at this node as it is shared by all programs that use it.</i>

 <p>A class <tt>Foo</tt> wishing to access preferences pertaining to its
 package can obtain a preference node as follows: <pre>
  static Preferences prefs = Preferences.systemNodeForPackage(Foo.class);
 </pre>
 This idiom obviates the need for using a string to describe the
 preferences node and decreases the likelihood of a run-time failure.
 (If the class name is misspelled, it will typically result in a
 compile-time error.)

 <p>Invoking this method will result in the creation of the returned
 node and its ancestors if they do not already exist.  If the returned
 node did not exist prior to this call, this node and any ancestors that
 were created by this call are not guaranteed to become permanent until
 the <tt>flush</tt> method is called on the returned node (or one of its
 ancestors or descendants).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - the class for whose package a system preference node is desired.
<DT><B>Returns:</B><DD>the system preference node associated with the package of which
         <tt>c</tt> is a member.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <tt>c</tt> is <tt>null</tt>.
<DD><CODE>java.lang.SecurityException</CODE> - if a security manager is present and
         it denies <tt>RuntimePermission("preferences")</tt>.<DT><B>See Also:</B><DD><CODE>RuntimePermission</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getMDSPathForExport(java.lang.String)"><!-- --></A><H3>
getMDSPathForExport</H3>
<PRE>
public static java.lang.String <B>getMDSPathForExport</B>(java.lang.String&nbsp;preferencePath)</PRE>
<DL>
<DD>Returns the full MDS path associated with the Preferences path
 passed into the method. This method is typically only used for
 Lifecycle operations.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>preferencePath</CODE> - The path to the Preferences node whose MDS root path
 is required, .e.g. "my/demo/app"
<DT><B>Returns:</B><DD>The full MDS path associated with the Preferences path. e.g.
 "/oracle/adf/share/prefs/$data/my/demo/app"</DL>
</DD>
</DL>
<HR>

<A NAME="getMDSPathForExport(java.util.prefs.Preferences)"><!-- --></A><H3>
getMDSPathForExport</H3>
<PRE>
public static java.lang.String <B>getMDSPathForExport</B>(java.util.prefs.Preferences&nbsp;prefs)</PRE>
<DL>
<DD>Returns the full MDS path associated with the Preferences object
 passed into the method. This method is typically only used for
 Lifecycle operations.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prefs</CODE> - The Preferences object whose MDS root path is required.
<DT><B>Returns:</B><DD>The full MDS path associated with the Preferences object.</DL>
</DD>
</DL>
<HR>

<A NAME="getSystemCustomizationClass()"><!-- --></A><H3>
getSystemCustomizationClass</H3>
<PRE>
public static oracle.mds.cust.CustomizationClass <B>getSystemCustomizationClass</B>()</PRE>
<DL>
<DD>Returns the CustomizationClass associated with the System
 Customizations.  This method is typically only used for
 Lifecycle operations.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the CustomizationClass associated with the System
 Customizations.</DL>
</DD>
</DL>
<HR>

<A NAME="getUserCustomizationClass()"><!-- --></A><H3>
getUserCustomizationClass</H3>
<PRE>
public static oracle.mds.cust.CustomizationClass <B>getUserCustomizationClass</B>()</PRE>
<DL>
<DD>Returns the CustomizationClass associated with the User
 Customizations.  This method is typically only used for
 Lifecycle operations.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the CustomizationClass associated with the User
 Customizations.</DL>
</DD>
</DL>
<HR>

<A NAME="setUsernameOverride(java.lang.String)"><!-- --></A><H3>
setUsernameOverride</H3>
<PRE>
public void <B>setUsernameOverride</B>(java.lang.String&nbsp;username)</PRE>
<DL>
<DD>Enables overriding the ADFContext based username derivation in 
 Preferences access.
 This override allows users of the api to obtain user preference
 values for users other than the logged in user, whose ID is used
 when not overridden by the UserCustomizationClass.
 In effect this method enables updating the getValue method of the 
 UserCustomizationClass such that the passed in username value is 
 returned instead of that of the username associated with the ADFContext.
 Note the preference nodes are held in managed map hence after use 
 one should set the UsernameOverride value to null to turn off the 
 override, enabling a revertion to the default behaviour, otherwise the 
 values for the last overridden user will be returned by processes 
 accessing the ADFPreferences in the same thread.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>username</CODE> - The username to be used by the UserCustomizationClass,
 in place of the default ADFContext derived logged in username.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Oracle Fusion Middleware Java API Reference for Oracle ADF Share<br>11g Release 1 (11.1.1.9.0)</b><br>E52934-01</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../oracle/adf/share/prefs/ADFPreferencesFactory.html" title="class in oracle.adf.share.prefs"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?oracle/adf/share/prefs/ADFPreferences.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ADFPreferences.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<center>Copyright &copy; 1997, 2015, Oracle. All rights reserved.</center>
</BODY>
</HTML>
